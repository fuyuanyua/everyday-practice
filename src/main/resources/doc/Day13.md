## Day13

##### 1.思考题

怎么避免MySQL死锁？

1. MySQL有三种锁：表级锁、行级锁、页级锁

   - 表级锁：MySQL中粒度最大的锁，会对整张表加锁。特点是开销小、加锁快、发生锁冲突概率最大、并发度最低、不会出现死锁。
   - 行级锁：MySQL中粒度最小的锁，只针对当前操作的行加锁。特点是开销大，加锁慢、发生锁冲突的概率最低、并发度最高、会出现死锁。
   - 页级锁：MySQL中粒度介于表级锁和行级锁中间的锁，一次锁定当前及与当前操的行相邻的一组记录，特点是中庸、会出现死锁。

2. 死锁产生的原因

   两个进程相互等待对方所占用的资源，造成两个进程一直在无限等待下去。例如事务1持有a锁，需要b锁，事务2持有b锁，需要a锁，事务1和事务2互相等待对方释放锁，造成一直循环等待下去，发生死锁。

3. 避免死锁

   - 使用MyISAM表引擎，因为使用表级锁，一次操作直接锁住所有需要的表，所以不会发生死锁，但带来的是并发性能的急剧下降。

   - 查出最近的死锁语句并分析

     ```
     SHOW ENGINE INNODB STATUS
     ```

   - 设置锁的超时时间，事务中某个锁请求超时，回滚此事务，设置方法如下：

     ```
     log-error =/xx/xxx.log
     innodb_lock_wait_timeout=60 #锁请求超时时间(秒)
     innodb_rollback_on_timeout = 1 #事务中某个语句锁请求超时将回滚真个事务
     innodb_print_all_deadlocks = 1 #死锁都保存到错误日志
     ```

   - 保持事务简短，事务越长，持有锁的时间也就越长，从而阻塞了其他事务并可能导致死锁。

   - 如果不同程序并发存取多个表，尽量以相同顺序访问表，大大降低死锁的概率。

##### 2.算法题

输入一个整数n，返回n的各位数字之积与各位数字之和的差。

```java
/**
 * 思路：
 *      获得数字n的个位数的方法是：n % 10，
 *      获得n的个位数后，要获得十位数：先n = n / 10，去掉个位数，然后n % 10，
 *      获得百位数的方法同上，依次类推下去
 * 时间复杂度：O(m)，m为数字n的位数
 * 空间复杂度：O(1)
 * @param n
 * @return
 */
public static int solution1(int n) {
    int abs = Math.abs(n);
    if (abs == 0) {
        return 0;
    }

    int sum = 0;
    int product = 1;

    while (abs > 0) {
        int num = abs % 10;
        abs = abs / 10;
        sum += num;
        product *= num;
    }

    return product - sum;
}
```