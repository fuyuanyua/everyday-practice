## Day22

##### 1.思考题

一条sql执行时间过长，应该从哪些方面分析和优化？

1. 看sql语句是否join了多张表进行查询，尽量不要join超过三张表，若实在业务需要，可以分别单表查询出结果后，在业务层处理；或者对表字段进行冗余，空间换时间，避免连接查询。
2. 看sql语句是否嵌套了子查询，嵌套子查询会降低查询效率。
3. 以下情况考虑建索引：
   - 经常跟在where后面的字段要创建索引
   - 外连接的字段要创建索引
   - 经常更新的字段不宜创建索引，插入更新等操作额外开销很大
4. 要注意避免以下情况，否则会导致索引失效：
   - 使用!=、<、>无法走索引，导致全表扫描
   - 字段不要做任何运算，否则索引失效
   - 字段类型和值要相同，否则出现隐式转换，索引失效
   - 使用or无法走索引，建议用union代替
   - like的通配符%在最左边，索引失效，建议用ES来做模糊搜索
5. 查看sql执行计划，分析是否走了索引，避免全表扫描
6. 对数据量很大的表，要考虑进行分表，否则数据量庞大后查询效率会很低

##### 2.算法题

一个 m * n 的矩阵，每行都是非递增的，每列也都是非递增的，求矩阵负数的个数

```java
/**
 * 思路：
 *      根据题意，此矩阵每行都是非递增，每列也都是非递增，
 *      那么可以发现规律：
 *      遍历某一行，若发现了第一个负数，那么这一行这个数字后面的所有数也都是负数，
 *      若发现的第一个负数正好就是这行的第一个数字，那么这行及以下的所有行全部都是负数
 * 时间复杂度：
 *      最差情况是扫描整个矩阵O(m * n)，
 *      最优情况是扫描到第一个行第一个数字就是负数，O(1)
 *      平均时间复杂度算不来
 * 空间复杂度：O(1)
 * @param input
 * @return
 */
public static int solution1(int[][] input) {
    // 行数
    int m = input.length;
    // 列数
    int n = input[0].length;

    // 用于统计负数
    int count = 0;
    // 停止遍历矩阵的标志
    boolean flag = false;

    for (int i = 0; i < m; i++) {
        int[] currentRow = input[i];
        for (int j = 0; j < n; j++) {
            if (currentRow[j] < 0) {
                if (j == 0) {
                    count += (m - i) * n;
                    flag = true;
                } else {
                    count += (n - j);
                }
                break;
            }
        }
        if (flag) {
            break;
        }
    }

    return count;
}
```



 	

